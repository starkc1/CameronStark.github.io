Complexity Analysis

Algorithm Analysis

Linear Search

    int search(int[] data, int val)
    {
        for (int i = 0; i < data.length; i++)
        {
            if (data[i] == val)
            {
                return i;
            }
            else 
            {

            }
        }
    }

Binary Search

    int binarySearch (int[] data, int val)
    {
        int start = 0, end = data.length;
        int mid;

        while (end > start) {
            mid = (start + end) / 2;
            if (data[mid] == val)
            {
                return mid;
            }
            else  if (data[mid] > val)
            {
                end = mid - 1;
            }
            else 
            {
                start = mid + 1;
            }
        }
        return -1;
    }


Criteria
    Correctness
    Simpicity
    Time consumed
    Space used

Time Complexity
    The determination of how much time is required to execute an algorithm
    Methods:
        Wall Clock Time
            Varies depending on state of computer
            Rigourous experimentation would be required
        Counting the number of operations executed
        Complexity analysis

Space Complexity
    The amount of space consumed through the exectution of the algorithm
    Space 
        Memory usage (Stack or Heap)
        Disk space

Analysis
    data set of size, n, and time, t, creating a function, f, expressing time with data set size, n,
        f(n)
    f(n) allows someone to consisdering the algorithmto know


EXAMPLE
    for (int i = 0; i < n; i++)
    {
        print(array[i]);
    }

    f(n) = ?
    print: 1 per iteration -> n
    i++: 1 per iteration -> n
    i < n: 1 per iteration plus 1 more -> n + 1
    i = 0; 1 -> 1
    f(n) = 3n + 2

EXAMPLE
    f(n) = n^2 + 2n + 100
    g(n) = n^2

    1, 10, 100, 1000, 10000
    f(n) = 103 : 220 : 10,300 : 1,002,100 : 100,020,100
    g(n) = 1 : 100 : 10,000 : 1,000,000 : 100,000,000

Asymptotic Complexity
    A measure of complexity in which the actual performance is not determined, but rather a good enough approximation is derived
        Keep terms that have significant impact on the magnitude
    Try to determine the number of iterations given the size of the data set

Big-O Notation
    Asymptotic upper bound
    f(n) is O(g(n)) if there exists some constants c and N such that 
        f(n) <= c*g(n) for all n >= N
    g(n) represents an upper bound for the algorithms complexity

EXAMPLE
    f(n) n^2 + 2n + 100
    f(n) = O(n^2)
        n^2 + 2n + 100 <= c*g(n)

Big-O tips
    Low ordered terms are ignored
        O(n^3 + 2n) = O(n^3)
    Multiplicative constant are ignored
        O(5n^3) = O(n^3)
    O(f(n)) + O(g(n)) = O(f(n) + g(n))
        O(n^2 + O(lg(n))) = O(n^2 + lg(n)) = O(n^2)

EXAMPLE

public int[][] matrixMultiply(int[][]A, int[][] B, int n)
{
    int[][] C = new int[][];

    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            for (int k = 0; k < n; k++)
            {
                C[i][j] = C[i][j] + A[i][k]*B[k][i];
            }
        }
    }
}

k loop:
    summation from k = 0 to n - 1 of [5 + 2] = 5n + 2

j loop:
    summation from j = 0 to n - 1 of ((5n + 2) + 2) = 5n^2 + 4n + 2

i loop:
    summation from i = 0 to n - 1 of ((5n^2 + 4n + 2)+ 2) + 2 =

f(n) = 5n^3 + 4n^2 + 4n + 2 -> n^3
O(n) = n^3

EXAMPLE

for (i = 0; i < n; i++)
{
    for (j = 1, sum = a[0]; j <= i; j++)
    {
        sum += a[j];
    }

    System.out.println("Sum= " + sum);
}

j loop:
    summation from j = 1 to i of (4 + 3) = 4i + 3

i loop:
    summation from i = 0 to n - 1 of ((4i + 3) + 5) + 2 = (4i + 8) + 2 = 2n^2 + 6n + 2

f(n) = 2n^2 + 6n + 2 -> n^2
O(n) = n^2 